[{"categories":["API"],"content":"Ceci est le premier article sur les API génériques, les API HTTP et l\u0026rsquo;Open API.\nJe vais commencer par établir une base commune sur ce qu\u0026rsquo;est une API générique et pourquoi une API est importante. Dans un premier temps comme une API est un artefact complexe, je vais montrer ses caractéristiques principales.\nPar la suite, je vais me concentrer sur les API basées spécifiquement sur HTTP et comment les représenter, puis j\u0026rsquo;expliquerai pourquoi, au lieu de créer votre propre méthode de documentation pour une API, vous devriez utiliser une méthode standard pour représenter les API HTTP, appelée Open API.\nIntroduction Ceci est le premier article sur les API génériques, les API HTTP et l\u0026rsquo;Open API.\nJe vais commencer par établir une base commune sur ce qu\u0026rsquo;est une API générique et pourquoi une API est importante. Dans un premier temps comme une API est un artefact complexe, je vais montrer ses caractéristiques principales.\nPar la suite, je vais me concentrer sur les API basées spécifiquement sur HTTP et comment les représenter, puis j\u0026rsquo;expliquerai pourquoi, au lieu de créer votre propre méthode de documentation pour une API, vous devriez utiliser une méthode standard pour représenter les API HTTP, appelée Open API.\nConcepts de base Pour permettre la communication entre deux composants logiciels distincts, il faut définir précisément comme le dialogue doit se passer.\nUn service est une application qui met sa fonctionnalité à disposition via une interface technique publiée, appelée contrat de service.\nUn contrat de service peut être décomposé en un ensemble de capacités de service. Chaque capacité de service est une fonction offerte à d\u0026rsquo;autres applications appelées consommatrices de service.\nTout logiciel utilisant un service est appelé un consommateur de service. De plus, le côté serveur est appelé producteur.\nLes composants peuvent être déployés dans le même processus ou dans des processus différents. S\u0026rsquo;ils sont dans des processus différents, ils peuvent s\u0026rsquo;exécuter sur la même machine ou sur des machines séparées.\nLes APIs qui nous intéressent sont celles destinées aux composants s\u0026rsquo;exécutant dans des processus séparés, sur des machines séparées. Notre cas d\u0026rsquo;intérêt est le calcul distribué.\nQue signifie API ? API est l\u0026rsquo;acronyme du nom anglais Application Programming Interface (en français Interface de Programmation d\u0026rsquo;Application).\nIl n\u0026rsquo;existe pas de définition officielle de l\u0026rsquo;API. Cependant, sur Internet, on peut trouver de nombreuses définitions. Certaines grandes entreprises de logiciels fournissent leur propre définition de l\u0026rsquo;API.\nAmazon Web Services dit : \u0026ldquo;Les API sont des mécanismes qui permettent à deux composants logiciels de communiquer entre eux à l\u0026rsquo;aide d\u0026rsquo;un ensemble de définitions et de protocoles.\u0026rdquo;\nIBM dit : \u0026ldquo;Une API, ou interface de programmation d\u0026rsquo;application, est un ensemble de règles définies qui permettent à différentes applications de communiquer entre elles.\u0026rdquo;\nMulesoft dit : \u0026ldquo;Une API est un intermédiaire logiciel qui permet à deux applications de communiquer entre elles.\u0026rdquo;\nRedhat dit : \u0026ldquo;Une API est un ensemble de définitions et de protocoles pour la construction et l\u0026rsquo;intégration de logiciels d\u0026rsquo;application.\u0026rdquo;\nToutes ces définitions s\u0026rsquo;accordent sur la communication entre deux morceaux de logiciel, et pour que la communication devienne réalité, les ordinateurs ont besoin d\u0026rsquo;un protocole, qui est un ensemble de règles bien définies. Deux applications qui souhaitent communiquer entre elles doivent établir un langage commun. Adhérer à une API revient à signer un contrat : plus le contrat est clair, mieux c\u0026rsquo;est.\nAujourd\u0026rsquo;hui, les API les plus populaires sont REST et SOAP, mais vous pourriez également être intéressé par la puissance de GraphQL. Si vous voulez approfondir les architectures basées sur les événements (en anglais EDA = Event Driven Architecture), vous devriez jeter un coup d\u0026rsquo;œil à AsyncAPI. AsyncAPI est une initiative open source visant à faciliter le travail avec les EDA autant que OpenAPI avec les API REST.\nPourquoi devrions-nous nous soucier des API ? Les API permettent à de nombreux systèmes de dialoguer. Dans les systèmes distribués, des API bien définies sont essentielles pour simplifier les interconnexions de services. Les applications qui communiquent avec d\u0026rsquo;autres applications sont aujourd\u0026rsquo;hui la norme. De plus, la grande majorité de toutes les applications monolithiques ne fonctionne pas de manière autonome. Par exemple, une petite application web qui doit authentifier les utilisateurs le fait le plus souvent via un service appelée Identity Provider, et ce composant aussi expose une API.\nUne fois que cette API est établie, le producteur et le consommateur peuvent être mis en œuvre dans n\u0026rsquo;importe quel langage et indépendamment l\u0026rsquo;un de l\u0026rsquo;autre.\nCaractéristiques d\u0026rsquo;une API Dans aucun ordre particulier, une API doit être :\nSécurisée - La sécurité est la caractéristique la plus importante qu\u0026rsquo;une API doit présenter. Une API permet de lire et/ou de modifier des données. Vous devez vous assurer que seules les personnes ou les systèmes autorisés peuvent le faire. Une API doit garantir que les données en transit ne peuvent pas être lues par des tiers. L\u0026rsquo;authentification, l\u0026rsquo;autorisation et le chiffrement sont essentiels.\nSans état - chaque demande doit contenir toutes les informations nécessaires pour être comprises par le serveur. On dit qu\u0026rsquo;un service est sans état si le serveur ne stocke pas de détails sur la session du client. En raison de cela le client ne peut pas supposer qu\u0026rsquo;une demande dépend d\u0026rsquo;une demande précédente. Le comportement est similaire à celui d\u0026rsquo;une fonction par rapport à celui d\u0026rsquo;un objet : une fonction appelée avec le même ensemble d\u0026rsquo;arguments donnera toujours le même résultat. Un objet, en revanche, peut exécuter la même opération à chaque fois. Attention : quant on parle d\u0026rsquo;un système sans état, en fait le système a bien un état mais ceci au lieu de se trouver dans le processus de l\u0026rsquo;API est dans une base de données.\nBien documentée - Une API peut être (et l\u0026rsquo;est généralement) un artefact complexe. Son utilisation doit être aussi simple que possible et les développeurs doivent pouvoir comprendre comment l\u0026rsquo;utiliser simplement en lisant la documentation. Les erreurs et leur signification doivent également être bien documentées.\nRésiliente - Les erreurs peuvent survenir. Lorsque le backend rencontre une erreur, le problème doit être clairement expliqué à l\u0026rsquo;appelant, avec des messages d\u0026rsquo;erreur bien codés, de sorte que, si la faute incombe à l\u0026rsquo;appelant, il puisse corriger l\u0026rsquo;appel et réessayer.\nInteropérable - une API doit faciliter la communication entre deux systèmes différents. Cela suppose que le protocole de communication et le codage doivent être clairement définis.\nDécouvrable - dans une organisation, de nombreuses API peuvent être présentes. Si une API ne peut pas être trouvée, elle n\u0026rsquo;existe pas. Pour cette raison, l\u0026rsquo;organisation pourrait commencer à créer une nouvelle API (pour trouver des traces de l\u0026rsquo;existence de l\u0026rsquo;API existante en cours de route) ou même abandonner le projet.\nCohérente - les points de terminaison d\u0026rsquo;une API devraient suivre des modèles similaires. Par exemple, la logique de lecture d\u0026rsquo;une liste de clients ne devrait pas être très différente de la lecture d\u0026rsquo;une liste d\u0026rsquo;articles.\nComment représenter une API ? Rien ne vous empêche de créer votre propre format d\u0026rsquo;API, mais en le faisant vous compliqueriez la communication entre deux systèmes. La communication entre deux systèmes est plus difficile si les systèmes sont hétérogènes, car la transmission de paramètres entrants et sortants exigent conversions de modèle et encodage/décodage de données. Il existe un grand nombre de représentations possibles d\u0026rsquo;une API. Pour exprimer clairement tous les aspects d\u0026rsquo;une API, il faut un formalisme bien défini, et le créer c\u0026rsquo;est certainement un défi. Ainsi, avant de vous lancer dans la création d\u0026rsquo;un langage pour représenter une API, il vaut mieux vérifier si une norme existe.\nEn fait, pour les API HTTP, une norme existe, elle s\u0026rsquo;appelle spécification OpenAPI.\nQu\u0026rsquo;est-ce que la spécification OpenAPI ? Selon le site officiel :\n\u0026ldquo;La spécification OpenAPI (OAS) définit une interface standard, indépendante du langage, pour les API HTTP, qui permet aux humains et aux ordinateurs de découvrir et de comprendre les capacités du service sans avoir accès au code source, à la documentation, ou à l\u0026rsquo;inspection du trafic réseau.\u0026rdquo;\nVeuillez noter que OpenAPI couvre les API HTTP en général dont les APIs REST sont un sous-ensemble.\nLa spécification OpenAPI ne se limite pas à la représentation d\u0026rsquo;une API HTTP, mais elle dispose également d\u0026rsquo;un écosystème bien établi. Des outils logiciels peuvent être utilisés pour traduire une définition OpenAPI en documentation consultable, pour générer du code côté client et serveur dans de nombreux langages de programmation. Des tests automatiques peuvent aussi être générés.\nEn fonction des besoins fonctionnels auxquels vous êtes confronté et de l\u0026rsquo;environnement technique dans lequel vous travaillez, vous avez un choix de normes API. En plus des protocoles API les plus largement utilisés aujourd\u0026rsquo;hui, tels que REST et SOAP, il existe d\u0026rsquo;autres alternatives telles que RAML et API Blueprint.\nConclusion Dans cet article introductif, j\u0026rsquo;ai présenté quelques concepts de base sur la communication entre les composants logiciels. Pour rendre une telle communication possible, une API doit être créée. Une bonne API devrait avoir des caractéristiques telles que la sécurité, l\u0026rsquo;interopérabilité et la cohérence. Après cette section conceptuelle, j\u0026rsquo;ai abordé le problème de la représentation d\u0026rsquo;une API et suggéré que, pour les API HTTP, un standard tel que OpenAPI est un bon choix. RAML et API Blueprint existent également, mais ils sont moins connus.\nDans l\u0026rsquo;article suivant, je plongerai dans de nombreux autres détails sur OpenAPI.\nSi vous avez des remarques sur le contenu ou la forme vous pouvez laisser un commentaire\u0026hellip; c’est en échangeant qu’on progresse.\nAuthor: Daniele Cremonini Reviewer: Emmanuel Quinton\n","date":"21-01-2024","img":"","permalink":"/fr/posts/c-est-quoi-une-api/","series":["Travailler avec les APIs"],"tags":[""],"title":"Introduction Aux APIs"},{"categories":[""],"content":"Un outil de mise en forme automatique peut-il augmenter la productivité ?\nLa réponse est oui.\nLe livre \u0026ldquo;The Pragmatic Programmer\u0026rdquo; parle de l\u0026rsquo;entropie du code. L\u0026rsquo;entropie est une grandeur physique liée au désordre moléculaire. C\u0026rsquo;est peut-être la seule grandeur physique que l\u0026rsquo;on puisse trouver dans un logiciel. Plus le désordre est important, plus l\u0026rsquo;entropie est élevée. Plus votre logiciel est entropique, plus - jour après jour - il sera difficile de travailler avec.\nPour expliquer pourquoi, je vais vous donner un exemple.\nLors de l\u0026rsquo;écriture d\u0026rsquo;un if-then-else dans un langage comme Java, où est-il préférable de mettre des parenthèses ?\nVous pouvez dire comment a), b) ou c) ou vous pouvez inventer une autre combinaison intermédiaire de votre goût.\na)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} else { 4 // your \u0026#34;else\u0026#34; code here 5} b)\n1if (condition) 2{ 3 // your \u0026#34;then\u0026#34; code here 4} 5else 6{ 7 // your \u0026#34;else\u0026#34; code here 8} c)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} 4else { 5 // your \u0026#34;else\u0026#34; code here 6} Les façons de mettre en page le code sont nombreuses : où mettre l\u0026rsquo;ouverture de l\u0026rsquo;accolade, si utiliser la tabulation ou l\u0026rsquo;espace pour mettre en retrait, si pour ajouter un espace après l\u0026rsquo;ouverture d\u0026rsquo;un crochet, où mettre les commentaires. Même l\u0026rsquo;écriture des conditions logiques peut se faire de plusieurs façons :\n1(a==b) ou\n1(a == b) ou\n1( a == b ) J\u0026rsquo;ai été témoin de diverses discussions animées sur le style qui est \u0026ldquo;meilleur\u0026rdquo; mais au-delà de cela qui peut en sortir, ce qui compte vraiment, c\u0026rsquo;est la cohérence. Pourquoi? Parce que, même si une personne peut ne pas aimer un certain style, au bout d\u0026rsquo;un moment elle finit par s\u0026rsquo;y habituer et lorsqu\u0026rsquo;elle s\u0026rsquo;y habitue, la lecture du code devient automatique. Le code devient plus intuitif. Si la mise en forme du code est incohérente, la lecture du code devient plus ardue. La fatigue augmente la probabilité de faire des erreurs. Il faudra du temps pour trouver ces erreurs et plus de temps pour les corriger. En fin de compte, ne pas mettre en forme votre code de manière cohérente entraîne une baisse de productivité.\nGarder votre code mis en forme de manière cohérente peut être un défi même pour un seul développeur, mais dans une équipe, vous pouvez être assuré que la cohérence ne durera pas. Les développeurs travaillent presque toujours en équipe. Pour une équipe, avoir une règle partagée signifie augmenter la productivité globale. Construisez un consensus autour d\u0026rsquo;un style de mise en forme de code et si vous ne pouvez pas, imposez-le. Même si vous rencontrez une certaine résistance au début, vos collègues s\u0026rsquo;y habitueront, se fatigueront moins et seront plus productifs.\nLa cohérence et l\u0026rsquo;ordre qui en résulte sont encore plus importants que le style de la mise en forme elle-même.\nSi on a un outil qui non seulement vérifie que les règles sont respectées mais qui aussi met en forme le code automatiquement, on obtient un deuxième gros avantage qui est de gagner du temps et du stress pour exécuter cette opération.\nLa définition d\u0026rsquo;un style de mise en forme pour un langage ayant une syntaxe moyennement complexe comme celle de Java peut nécessiter des dizaines de règles et pour ce qui a été dit plus haut, il est bon que ces règles soient cohérentes dans les différents cas qui peuvent se présenter.\nQue se passe-t-il si vous décidez d\u0026rsquo;appliquer des règles de mise en forme à un projet composé de plusieurs fichiers ? Faut-il mettre en forme tous les fichiers en une seule fois ou vaut-il mieux procéder progressivement en ne mettant traiter que quelques fichiers à la fois ?\nSi un projet a un historique de quelques jours, mettre en forme tous les fichiers en une seule fois n\u0026rsquo;a pas un gros impact sur la traçabilité des changements dans le log du système de gestion source (git par exemple) mais si les fichiers sont plusieurs centaines avec plus développeurs qui travaillent avec et peut-être en mode asynchrone (comme cela se produit généralement sur un projet open source) mettre en forme petit à petit est vraiment une nécessité.\nEnfin, comme il vaut mieux ne pas avoir à s\u0026rsquo;inquiéter à chaque fois que l\u0026rsquo;on tape sur le code pour le mettre en page, il vaut mieux avoir un déclenchement automatique de cette opération.\nEnsuite, vous devez créer l\u0026rsquo;outil logiciel qui lit le code, applique les règles et l\u0026rsquo;exécute sur chaque version.\nVoulez-vous savoir comment nous avons fait toutes ces choses dans notre API Happraisal ?\nNous avons choisi une solution toute faite. Dans le monde open source, il y en a. Nous avons choisi Spotless car en plus de nous permettre d\u0026rsquo;analyser le code et de le mettre en forme, il est également multi-language. Spotless ne se limite pas à Java mais gère également C, JavaScript, TypeScript, yaml, JSON, SQL et autres.\nLe référentiel Spotless est sur GitHub : https://github.com/diffplug/spotless Spotless peut être intégré dans les versions basées sur Maven et Gradle via des plugins.\nPour l’utiliser dans Happraisal nous avons importé un plugin dans Gradle et plus bas nous avons inclus un fichier de configuration via la commande apply :\nbuild.gradle\n1plugins { 2 // other plugins 3 id \u0026#34;com.diffplug.spotless\u0026#34; version \u0026#34;6.2.1\u0026#34; 4} 5 6// Include the configuration for Spotless 7apply from: \u0026#34;gradle / spotless.gradle\u0026#34; Notre gradle/spotless.gradle se compose de trois parties. Le premier est ratchetFrom qui, s\u0026rsquo;il est spécifié, permet d\u0026rsquo;appliquer la mise en forme de manière incrémentielle uniquement aux fichiers modifiés par rapport à la branche spécifiée qui dans le cas de Happraisal à origin/develop car c\u0026rsquo;est la branche vers laquelle convergent les demandes de fusion. Fondamentalement, chaque fois que nous ajoutons du code à Origin/développons Spotless, cela nous oblige à ne pas aggraver la situation. Le paramètre spécifié dans ratchetFrom peut être quelque chose de plus compliqué, pour en savoir plus vous pouvez consulter ce fichier : https://javadoc.io/static/org.eclipse.jgit/org.eclipse.jgit/5.6.1.202002131546-r/org/eclipse/jgit/lib/Repository.html#resolve-java.lang.String- Note linguistique : Le mot ratchet en anglais signifie que la règle peut être plus stricte (ou rester inchangée) mais ne peut pas devenir moins stricte.\nLa deuxième section appelée \u0026ldquo;misc\u0026rdquo; vous permet de spécifier des règles de mise en forme pour les fichiers qui peuvent être identifiés via l\u0026rsquo;extension gradle ou md.\nLa troisième section est dédiée à Java. Dans la section Java, il y a un appel à googleJavaFormat qui est une application dédiée exclusivement à la mise en forme du code Java.\nGoogle Java Format se trouve sur GitHub : https://github.com/google/google-java-format et dans les balises vous trouverez toutes les versions publiées (par exemple 1.13).\nSi vous n\u0026rsquo;aimez pas le style de mise en forme imposé par Google et que vous souhaitez vous orienter sur un style configurable alors vous devez passer à un metteur un forme Eclipse. Je vous renvoie au site Spotless pour plus d\u0026rsquo;informations.\nNotez que Spotless vous permet également de gérer les en-têtes des licences logicielles via la commande licenseHeader.\n1spotless { 2// optional: limit format enforcement to just the files changed by this feature branch 3ratchet From \u0026#39;origin/develop\u0026#39; 4 5 format \u0026#39;misc\u0026#39;, { 6 // define the files to apply `misc` to 7 target \u0026#39;* .gradle\u0026#39;, \u0026#39;* .md \u0026#39;,\u0026#39; .gitignore \u0026#39; 8 9 // define the steps to apply to those files 10 trimTrailingWhitespace () 11 indentWithSpaces () // tab or spaces. indentWithSpaces takes an integer argument, the default value is 4 12 endWithNewline () 13 } 14 15 java { 16 // don\u0026#39;t need to set target, it is inferred from Java 17 18 // apply a specific flavor of google-java-format 19 googleJavaFormat (\u0026#39;1.13. 0 \u0026#39;). ReflowLongStrings () 20 // make sure every file has the following copyright header. 21 // optionally, Spotless can set copyright years by digging 22 // through git history. 23 licenseHeader \u0026#39;/ * (C) $ YEAR * /\u0026#39; 24 } 25} Résumé L\u0026rsquo;application de règles strictes à la mise en forme du code réduit l\u0026rsquo;effort et le stress des développeurs et augmente leur productivité. Il serait préférable de partager un style de mise en forme au niveau de l\u0026rsquo;équipe, mais si vous n\u0026rsquo;y arrivez pas par consensus, cela vaut la peine d’en imposer un, car après un certain temps, les gens s\u0026rsquo;y habituent. Une fois que vous avez décidé d\u0026rsquo;un style, il est bon d\u0026rsquo;avoir un outil automatisé pour vérifier que la mise en forme est cohérente. Disposer d\u0026rsquo;un outil pour appliquer automatiquement la mise en forme permet de gagner du temps et d\u0026rsquo;éliminer une tâche mécanique. Spotless est un outil open source qui peut être intégré via des plugins avec Maven et Gradle. Spotless vous permet de mettre en page votre code progressivement afin de ne pas avoir à faire un méga commit au moment de son introduction.\nSi vous lisez cette phrase c’est que vous avez lu cet article en entier et je vous en remercie car c’est mon premier article, si vous avez des remarques sur le contenu, la forme vous pouvez laisser un commentaire…\nC’est en échangeant qu’on progresse.\nAuteur : Daniele Cremonini Relecteur : Emmanuel Quinton\n","date":"16-01-2023","img":"","permalink":"/fr/posts/qu-est-ce-que-la-mise-en-page-du-code-et-pourquoi-est-ce-important/","series":["Outils pour Java"],"tags":[""],"title":"Qu'est-Ce Que La Mise en Page Du Code Et Pourquoi Est-Ce Important"},{"categories":["qualité"],"content":"Préambule Il y a peu on m’a montré une application qui avait été faite assez récemment, mais qui avait l’aspect d’une application il y a dix ou quinze ans. Suite à ça j’ai trouvé qu’il serait intéressant d’essayer de faire évoluer une application semblable à celle qui m’a été présentée vers une architecture de qualité. Au travers de ce premier article nous présenterons l’application (ici ) pour laquelle nous ferons un état des lieux et nous définirons les axes d\u0026rsquo;amélioration que nous mettrons en place dans les prochains articles de cette série.\nPrésentation de l’application Fonctionnellement L’API permet de gérer des entretiens entre un manager et ses managés. Les règles de gestion sont : Un entretien :\n concerne un manager et un salarié. possède un formulaire  Un formulaire :\n possède des questions réponses simples saisissables dans un champ texte. peut être associés à une note que seule le manager peut voir  Un manager\n peut créer un entretien peut créer une note visible que par lui  Techniquement L’application est en java 11, elle a été générée par l\u0026rsquo;initilaizer de Spring (). La base de donnée est du H2 (problème que nous fixerons rapidement)\nLes problèmes En regardant rapidement le code nous pouvons constater plusieurs types de problèmes :\n des problèmes de documentations des problèmes de qualités des problèmes d’architectures  Des problèmes de documentation readme vide Par convention le README est le point d’entrée de toute application ; il doit permettre à de nouveaux arrivants de comprendre, de lancer et tester l’application. Il devrait donc contenir en plus d’une présentation rapide de l’API\n Les instructions pour compiler le code Les instructions pour lancer l\u0026rsquo;application en locale Les données permettant de se connecter en local si besoin  Absence de swagger (ou autre) Afin de tester une api facilement il est nécessaire d’avoir un outil permettant de lancer des requêtes cela peut aller de scripts postman à un Swagger complètement intégré.\nDes problèmes de qualité Absence de tests Le projet ne contient qu’un seul test, celui généré par l’initializer de Spring. Nous sommes d’accord pour dire qu’il est logiquement impossible pour un test d\u0026rsquo;assurer qu\u0026rsquo;aucun bug n’est présent. Il permet de vérifier à minima que l’application fait ce qu’elle doit faire. Dans le cas présent, sans tests, ce minimum n’est pas assuré et toute ré-factorisation est donc déconseillée puisque toute régression ne pourrait être identifiée. Pour un projet déjà existant et pour lequel il y a un manque de test il est possible de commencer par des tests de composants afin de couvrir un maximum de code.\nAbsence de paramétrage et de ci(cd) La CI/CD, intégration et déploiement continu, est un élément indispensable au suivi de la fonctionnalité du code. Il permet entre autre :\n de lancer un build du code de lancer les tests en distinguant les tests par type de lancer des tests visant la qualité du code avec des plugins come Checkstyle ou Spotless de vérifier la couverture du code de créer des images docker de déployer l’api sur un environnement donné  La CI/CD peut être lancée après un push sur une branche, la création du pull request (ou merge request), le merge sur la branche de référence\nAbsence d’outils pour contrôler la qualité du code. La qualité du code peut se définir par sa lisibilité et le respect des règles de programmations (quelles soient propres à l’entreprise ou définies avec un outil comme SonarQube). La revue de code est là pour valider ces points, mais elle peut être facilitée par la mise en place d’outils tels que :\n l’utilisation de plugins (maven ou gradle) comme Checkstyle ou Spotless qui seront lancés lors des builds l’utilisation d’un code style (comme google-java-format) dans l’ide pour s’assurer du bon formatage L’utilisation d’un plugin comme SonarLint qui permet de vérifier la qualité du code par rapport aux quality gates de l’entreprise  Des problèmes d\u0026rsquo;architecture Utilisation d’une base H2 Le premier point est plus un oubli de notre part lors de la création de l’application de base : c’est l’utilisation de la base H2 et non pas l’utilisation d’une base comme Postgresql ou Mysql. Il va de soi que l’utilisation d’une base embarquée n’est pas compatible avec l’utilisation d\u0026rsquo;une application (API) en production.\nL’utilisation d’une architecture en layers \\ L\u0026rsquo;utilisation d\u0026rsquo;une architecture en layers favorise une modélisation à partir de la base de données. Ceci empêche :\n de paralléliser les développements : les entités et les repositories doivent être créés pour que cela fonctionne. Le schéma de la base de données sert souvent de base du modèle métier  Mélange des domaines métier En regardant le code, il apparaît que les différents métiers : gestion des personnes, gestion des formulaires et gestion des notes sont tous liés. Ce mélange des métiers engendre une diminution de la robustesse du code ; plus le nombre de fonctionnalités est grand, plus le nombre de raisons de changer le code est grand et donc plus le risque d’avoir des régressions augmente. L’application du principe de \u0026ldquo;responsabilité unique” permettrait déjà une première séparation des classes.\nLes articles à venir Les points identifiés dans cet article feront l’objet d’une série d’articles qui présenteront la façon de les corriger et nous permettront d’améliorer notre API.\nLes premiers articles porteront entre autres sur :\n La mise en place de tests La mise en place d’une architecture hexagonale avec ArchUnit La mise en place de SonarQube La mise en place de la qualité et la correction du code smell  Si vous lisez cette phrase, c’est que vous avez lu cet article en entier et je vous en remercie car, c’est mon premier article, si vous avez des remarques sur le contenu, la forme vous pouvez laisser un commentaire\u0026hellip; c’est en échangeant qu’on progresse.\nÉcrit par : Emmanuel Quinton Revue par : Daniele Cremonini\n","date":"15-01-2023","img":"","permalink":"/fr/posts/comment-faire-evoluer-application-presentation/","series":["Comment faire évoluer une application pour la rendre plus robuste et maintenable"],"tags":[""],"title":"Comment Faire Évoluer Une API Pour La Rendre Plus Robuste Et Maintenable - Presentation"},{"categories":["qualité","test"],"content":"Série Comment faire évoluer une application - Mise en place des Tests Préambule Dans l’article d’introduction de cette série (lien) nous avons présenté les différents problèmes de notre application (ajouter le lien). Le premier que je vous propose de résoudre dans cet article est l’ajout de tests. Cet ajout de tests n’a pas pour unique but de couvrir du code et faire passer une quality gate ; il est là pour valider les règles métier et permettre une refactorisation avec moins de risques. Dans cet article, nous verrons comment ajouter des tests à une application qui n’en a pas. On abordera les tests unitaires, les tests d’intégrations et les tests de systèmes.\nDéfinitions des différents types de tests Un test unitaire est un test qui ne vérifie que la méthode d’une classe ou une classe. Les classes externes, souvent appelées “collaborateurs”, qui pourraient être appelées seront mockées. Nous placerons des tests unitaires essentiellement sur les services qui doivent contenir le code métier, c\u0026rsquo;est-à-dire le code avec de la valeur ajoutée. Un test d’intégration est un test qui à pour objectif de vérifier la bonne intégration de certaines parties d’un traitement et non celui-ci dans son ensemble. On concentrera nos tests d’intégration sur les endpoints et les repositories. Un test système est un test en boite noir qui va vérifier que l’ensemble du cas d\u0026rsquo;utilisation fonctionne.\nDans un cas comme celui de notre application, où aucun test n’existe, il est préférable de partir sur un test système pour vérifier rapidement le bon fonctionnement et la non-régression d’une fonctionnalité puis par la suite d’augmenter les tests unitaires et les tests d’intégration.\nTests unitaires Notre application étant en java, nous utiliserons comme librairies pour les tests : Junit5, Mockito et AssertJ.\nParamétrage du test Les dépendances sont à ajouter dans le build.gradle mais pour des raisons de lisibilité, je préfère créer un fichier unit-test.gradle qui contiendra toutes les configurations nécessaires. Ce fichier est appelé par le fichier build.gradle\nEmplacement du fichier unit-test.gradle\nContenu du fichier unit-test.gradle\n1dependencies { 2 3 testImplementation group: \u0026#39;org.junit.jupiter\u0026#39;, name: \u0026#39;junit-jupiter\u0026#39;, version: \u0026#39;5.8.2\u0026#39; 4 testImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-junit-jupiter\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 5 testImplementation group: \u0026#39;org.assertj\u0026#39;, name: \u0026#39;assertj-core\u0026#39;, version: \u0026#39;3.21.0\u0026#39; 6 testImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 7} 8 Dans le fichier build.gradle\n1apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; Mise en place d’un test Les règles pour écrire un test unitaire :\n Chaque test doit être créé dans le répertoire test Chaque classe de test se trouve dans le même package que la classe qu’il teste Le nom des méthodes de tests sont en snack_case (cf https://en.wikipedia.org/wiki/Snake_case ) Le nombre de choses testées doit être limité, idéalement à 1.  Exemple de test 1 2@Test 3void should_add_question_to_form() { 4 // given 5 var formId = UUID.fromString(\u0026#34;18b8f2e2-f41c-4ca4-a007-c328390cd099\u0026#34;); 6 var savedForm = new Form(); 7 var existingQuestion = new QuestionAnswer(formId, \u0026#34;What is your first name\u0026#34;, null, savedForm); 8 var questions = new HashSet\u0026lt;QuestionAnswer\u0026gt;(); 9 questions.add(existingQuestion); 10 savedForm.setQuestions(questions); 11 savedForm.setId(formId); 12 13 BDDMockito.when(formRepository.getById(formId)).thenReturn(savedForm); 14 15 var questionToSave = 16 new QuestionAnswer(null, \u0026#34;What is your objectives for the next year\u0026#34;, null, null); 17 18 // when 19 formService.createQuestion(formId, questionToSave); 20 21 // then 22 var questionAnswerArgumentCaptor = ArgumentCaptor.forClass(QuestionAnswer.class); 23 24 BDDMockito.then(questionAnswerRepository).should().save(questionAnswerArgumentCaptor.capture()); 25 var actualQuestions = questionAnswerArgumentCaptor.getValue(); 26 BDDSoftAssertions.thenSoftly( 27 softly -\u0026gt; { 28 softly.then(actualQuestions).isNotNull(); 29 softly.then(actualQuestions) 30 .extracting(\u0026#34;form.questions\u0026#34;, Assertions.as(InstanceOfAssertFactories.COLLECTION)) 31 .hasSize(2); 32 }); 33} 34 Détail du code Les points les plus importants sont :\n L\u0026rsquo;utilisation de mock pour simuler le comportement des méthodes d’autre classes qui sont appelées  1BDDMockito.when(formRepository.getById(formId)).thenReturn(savedForm); 2  L’utilisation d’ArgumentCaptor pour choper et ensuite valider le formulaire passé à la méthode save du repository  1 var questionAnswerArgumentCaptor = ArgumentCaptor.forClass(QuestionAnswer.class); 2 3 BDDMockito.then(questionAnswerRepository).should().save(questionAnswerArgumentCaptor.capture()); 4 var actualQuestions = questionAnswerArgumentCaptor.getValue(); 5  L’utilisation de SoftAssertions pour pouvoir vérifier plusieurs choses. Contrairement à une validation via la classe Assertions qui va lever une erreur à la première erreur, SoftAssertions va tester toutes les conditions et remonter les erreurs par la suite.  1 BDDSoftAssertions.thenSoftly( 2 softly -\u0026gt; { 3 softly.then(actualQuestions).isNotNull(); 4 softly.then(actualQuestions) 5 .extracting(\u0026#34;form.questions\u0026#34;, Assertions.as(InstanceOfAssertFactories.COLLECTION)) 6 .hasSize(2); 7 }); Tests d’intégrations Paramétrage du test Pour la mise en place des tests d’intégration, nous allons créer un répertoire au même niveau que les répertoires test et main.\nLa séparation des tests unitaires et des tests d’intégration a l’avantage de nous permettre de distinguer quel type de tests on souhaite exécuter et quand cela aura son utilité lors de la mise en place de la CI/CD La configuration se fera comme dans les tests unitaires via un fichier gradle séparé.\nEmplacement du fichier integration-test.gradle\nContenu du fichier integration-test.gradle\n1sourceSets { 2 integrationTest { 3 java { 4 compileClasspath += sourceSets.main.output 5 runtimeClasspath += sourceSets.main.output 6 srcDir file(\u0026#39;src/integration-test/java\u0026#39;) 7 } 8 resources.srcDir file(\u0026#39;src/integration-test/resources\u0026#39;) 9 } 10} 11 12configurations { 13 integrationTestImplementation.extendsFrom implementation 14 integrationTestRuntimeOnly.extendsFrom runtimeOnly 15} 16 17dependencies { 18 integrationTestImplementation group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-test\u0026#39; 19 integrationTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 20 integrationTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-inline\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 21} 22 23tasks.register(\u0026#39;integrationTest\u0026#39;, Test) { 24 description = \u0026#39;Runs integration tests.\u0026#39; 25 group = \u0026#39;verification\u0026#39; 26 27 testClassesDirs = sourceSets.integrationTest.output.classesDirs 28 classpath = sourceSets.integrationTest.runtimeClasspath 29 shouldRunAfter test 30 useJUnitPlatform() 31} 32 33check.dependsOn integrationTest Dans le fichier build.gradle\n1apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; 2apply from: \u0026#34;gradle/integration-test.gradle\u0026#34; 3 Mise en place d’un test La durée des tests d’intégrations étant plus longs, on va les limiter aux controllers et aux repositories ; les services, ont l’a vu plus haut, sont testés par des tests unitaires. Au niveau des controllers on aura pour objectifs de vérifier que les endpoints répondent correctement, c\u0026rsquo;est-à-dire qu’on vérifiera :\n la validité du statut retourné. la remontée d’erreur suite à une invalidité des paramètres ou dans le corp de la requête  Les services appelés dans les controllers seront mockés, les appels aux méthodes des services pourront être validés. Cette façon de tester nous fait comprendre pourquoi il faut limiter le code métier dans les controllers. Au niveau des repositories nous vérifierons la validité des requêtes, on se concentrera dans un premier temps sur les requêtes les plus complexes.\nExemple de test d\u0026rsquo;intégration d’un controller\n1@WebMvcTest(controllers = InterviewController.class) 2public class InterviewControllerITest { 3 4 @Autowired Jackson2ObjectMapperBuilder mapperBuilder; 5 6 @Autowired private MockMvc mockMvc; 7 8 @MockBean private InterviewService interviewService; 9 10 @Test 11 @DisplayName(\u0026#34;Should get all interviews\u0026#34;) 12 void should_get_persons() throws Exception { 13 // when 14 mockMvc 15 .perform( 16 MockMvcRequestBuilders.get(\u0026#34;/interviews\u0026#34;) 17 .contentType(MediaType.APPLICATION_JSON) 18 .accept(MediaType.APPLICATION_JSON)) 19 .andExpect(MockMvcResultMatchers.status().isOk()); 20 21 // then 22 BDDMockito.then(interviewService).should().findAll(); 23 } 24 25 Exemple de test d\u0026rsquo;intégration d’un repository\n1 2@DataJpaTest 3@ActiveProfiles(\u0026#34;it\u0026#34;) 4public class FormRepositoryITest { 5 @Autowired 6 private FormRepository formRepository; 7 8 @Test 9 void should_create_form() { 10 // given 11 var questionAnswer = new QuestionAnswer(null, \u0026#34;What do you think about your work this year\u0026#34;, null, null); 12 var formToSave = new Form(null, Set.of(questionAnswer)); 13 14 // when 15 var actualForm = formRepository.save(formToSave); 16 17 // then 18 var idNotNull = new Condition\u0026lt;Form\u0026gt;((Form form) -\u0026gt; form.getId() != null, \u0026#34;form id not null\u0026#34;); 19 var asOneQuestion = new Condition\u0026lt;Form\u0026gt;((Form form) -\u0026gt; form.getQuestions().size() == 1, \u0026#34;form has only one question\u0026#34;); 20 BDDAssertions.then(actualForm) 21 .as(\u0026#34;Check if a new form has been saved.\u0026#34;) 22 .has(idNotNull) 23 .has(asOneQuestion); 24 } 25 26 Détail du code Test des endpoints Pour les tests des endpoints on annote les classes tests avec @WebMvcTest , qui permet de charger un environnement minimal afin de pouvoir tester uniquement le controller défini dans l’annotation.\n1@WebMvcTest(controllers = InterviewController.class) La classe MockMvc de spring permet de tester les endpoint sans pour autant charger tout le contexte de l’application.\n1 mockMvc 2 .perform( 3 MockMvcRequestBuilders.get(\u0026#34;/interviews\u0026#34;) 4 .contentType(MediaType.APPLICATION_JSON) 5 .accept(MediaType.APPLICATION_JSON)) 6 .andExpect(MockMvcResultMatchers.status().isOk()); Afin de tester uniquement l\u0026rsquo;endpoint (code retour, objet retourné …) on mock le service qui est appelé avec l’annotation @MockBean de spring\n1 @MockBean private InterviewService interviewService; Test des repositories Les tests d\u0026rsquo;intégration entre un repository et la bases de données se fait avec l’annotation @DataJpaTest  Lors d’un test d’enregistrement d’un objet, il est possible de vérifier l’identifiant généré de l’objet en retour Pour des méthodes de type find, findAll, findId nous pouvons utiliser l\u0026rsquo;annotation @Sql afin de peupler la base de données avant de faire le test. Ceci se révèle utile lorsque la base de données au démarrage est vide. Ici je ne l’ai pas fait, mais il est tout à fait possible de démarrer les tests avec une base de données pré-initialisée.\n1@Sql(scripts = {\u0026#34;/sql_scripts/initialize_form.sql\u0026#34;} ) Tests system Paramétrage du test Tout comme pour les tests d’intégration les tests system sont dans un répertoire distinct ; La configuration se trouve dans le fichier system-test.gradle\nEmplacement du fichier system-test.gradle\nContenu du fichiersystem-test.gradle\n1sourceSets { 2 systemTest { 3 java { 4 compileClasspath += sourceSets.main.output 5 runtimeClasspath += sourceSets.main.output 6 srcDir file(\u0026#39;src/system-test/java\u0026#39;) 7 } 8 resources.srcDir file(\u0026#39;src/system-test/resources\u0026#39;) 9 } 10} 11 12configurations { 13 systemTestImplementation.extendsFrom implementation 14 systemTestRuntimeOnly.extendsFrom runtimeOnly 15} 16 17dependencies { 18 systemTestImplementation group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-test\u0026#39; 19 systemTestImplementation group: \u0026#39;io.rest-assured\u0026#39;, name: \u0026#39;rest-assured\u0026#39;, version: \u0026#39;4.4.0\u0026#39; 20 systemTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 21 systemTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-inline\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 22 23 24} 25 Dans le fichier build.gradle\n1 2apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; 3apply from: \u0026#34;gradle/integration-test.gradle\u0026#34; 4apply from: \u0026#34;gradle/system-test.gradle\u0026#34; 5 6systemTest { 7 shouldRunAfter integrationTest 8} 9 Mise en place d’un test 1 2@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 3class PostInterviewTest { 4 @Autowired Jackson2ObjectMapperBuilder mapperBuilder; 5 6 @LocalServerPort 7 8 private Integer port; 9 10 @BeforeAll 11 public static void setup() { 12 RestAssured.baseURI = \u0026#34;http://localhost\u0026#34;; 13 } 14 @Test 15 @Sql(scripts = \u0026#34;/sql_scripts/init_database.sql\u0026#34;) 16 void should_create_interview() throws JsonProcessingException { 17 var manager = 18 new Person(UUID.fromString(\u0026#34;8a37adbc-0c29-491a-8b6f-f10a4219fb91\u0026#34;), null, null, true); 19 var employee = 20 new Person(UUID.fromString(\u0026#34;3556c835-3bcd-420e-bb6e-a8b7c0bb139d\u0026#34;), null, null, false); 21 var form = new Form(UUID.fromString(\u0026#34;df9b2aad-d32e-469e-b434-be71a5531a35\u0026#34;), new HashSet\u0026lt;\u0026gt;()); 22 var interview = new Interview(null, Instant.now(), manager, employee, form); 23 24 RestAssured.given() 25 .header(\u0026#34;Content-type\u0026#34;, \u0026#34;application/json\u0026#34;) 26 .and() 27 .port(port) 28 .body(mapperBuilder.build().writeValueAsString(interview)) 29 .when() 30 .post(\u0026#34;/interviews\u0026#34;) 31 .then() 32 .statusCode(HttpStatus.SC_CREATED); 33 } 34} 35 Détails du code Les points à noter dans ce test sont :\n L’utilisation de l’annotation SpringBootTest qui permet de charger l’ensemble du contexte spring. L’utilisation de RestAssured pour tester les endpoints.  Résumé  Il existe trois types de bases de tests : les tests unitaires qui testent une méthode et uniquement le contenu de la méthode, les tests d’intégration qui valident la bonne intégration entre deux couches (appel des endpoints, connexion repository / base de données) et enfin les tests systèmes qui permettent de valider le bon fonctionnement d’une fonctionnalité Pour une API existante et dépourvue de tests, il est possible de commencer par la mise en place de tests système sur les endpoints les plus critiques puis d’ajouter progressivement des tests d’intégration et des tests unitaires. Pour une nouvelle API il est préférable de commencer par des tests unitaires et de progresser vers les tests systèmes  Si vous avez des remarques sur le contenu, la forme vous pouvez laisser un commentaire… c’est en échangeant qu’on progresse.\nÉcrit par : Emmanuel Quinton Revue par : Daniele Cremonini\n","date":"15-01-2023","img":"","permalink":"/fr/posts/comment-faire-evoluer-une-application-pour-la-rendre-plus-robuste-et-maintenable-mise-en-place-de-tests/","series":["Comment faire évoluer une application pour la rendre plus robuste et maintenable"],"tags":[""],"title":"Comment Faire Évoluer Une Application Pour La Rendre Plus Robuste Et Maintenable - Mise en Place De Tests"},{"categories":null,"content":"","date":"01-07-2022","img":"","permalink":"/fr/offline/","series":null,"tags":null,"title":"Hors Ligne"},{"categories":[""],"content":"Vous êtes-vous déjà retrouvé coincé en écrivant un morceau de code particulièrement compliqué et avez compris ce qui n\u0026rsquo;allait pas au moment exact où vous avez demandé de l\u0026rsquo;aide à un collègue ?\nExpliquez votre code à un canard (si c’est en caoutchouc , il restera toujours à portée de main sur votre bureau) et vos idées se clarifieront vite fait.\nIl peut sembler bizarre mais si au lieu de lire en boucle votre code, vous le racontez à quelqu\u0026rsquo;un, votre cerveau souvent dévoile le mystère. L\u0026rsquo;idée d’expliquer le code à un canard en caoutchouc a été popularisée par le livre de David Thomas et Andrew Hunt \u0026ldquo;The Pragmatic Programmer\u0026rdquo;. La méthode fonctionne. Cela explique le logo.\nMais qu’est-ce qui nous a poussés à créer un site qui vous incite à parler à un canard?\nNous avons fait plusieurs constats :\n Il nous arrive souvent de tomber sur du code non mis à jour quand on allait voir le code associé à des articles. Dans de nombreux cas, les projets associés aux articles sont dépourvus de tests. La qualité du logiciel est un sujet peu connu ou négligé en faveur de différents facteurs qui presque jamais sont justifiable en termes rationnels.  L\u0026rsquo;idée première de ce site est donc de présenter des articles et des méthodologies auxquels seront associés des projets ayant la même qualité que celle qui nous est demandée dans notre travail et d\u0026rsquo;assurer un suivi des mises à jours de ces projets.\nPar extensions, l\u0026rsquo;idée est également de présenter des articles autour de notre métier de développeur; peut être de présenter des livres qui nous auront interpellés.\nDans tous les cas les sujets ne seront qu\u0026rsquo;un reflet de ce que nous pensons, notre savoir faire mais en aucun cas se ne sont des points de vus fermés car pour progresser il faut savoir entendre l\u0026rsquo;avis des autres et accepter qu\u0026rsquo;il y a différentes façons de faire.\n","date":"13-01-2022","img":"","permalink":"/fr/about/","series":[""],"tags":[""],"title":"About"},{"categories":null,"content":"render = never\n+++ title = \u0026ldquo;Contactez nous\u0026rdquo; layout = \u0026ldquo;contact\u0026rdquo; [menu.footer] parent = \u0026ldquo;support\u0026rdquo; weight = 6 pre = \u0026lsquo;\u0026rsquo; +++\n","date":"01-01-0001","img":"","permalink":"/fr/contact/","series":null,"tags":null,"title":""}]
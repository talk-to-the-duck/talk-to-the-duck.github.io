[{"categories":["quality"],"content":"How to evolve an application to make it more robust and maintainable - Presentation Foreword Recently I was shown an application that had been created quite recently but which looked like an application from ten or fifteen years ago. After that I thought it would be interesting to try to make an application similar to the one I was shown evolve towards a quality architecture. Through this first article we will present the application (cf link to GitHub) for which we will make a state of the art, and we will define the axes of improvement that we will set up in the next articles of this series.\nPresentation of the application Functionally The API allows to manage interviews between a manager and his mentees. The management rules are:\nAn interview:\n concerns a manager and an employee. has a form  A form:\n has a simple answer to each question. An answer can be entered in a text field. can be associated with a note that only the manager can see  A manager\n can create an interview can create a note visible only to him/her  Technically The application is written in java 11, it was generated by the Spring initilaizer (). The database is H2 (problem that we will fix quickly)\nThe problems A quick look at the code shows several types of problems:\n documentation problems quality problems architecture problems  Documentation problems an empty readme By convention the README is the entry point to any application; it should allow newcomers to understand, launch and test the application. It should therefore contain in addition to a quick presentation of the API\n Instructions for compiling the code Instructions for running the application locally Data to use locally if needed  no swagger (or other) In order to test an API easily it is necessary to have a tool to run queries, which can range from Postman scripts to a fully integrated Swagger.\nQuality problems no tests The project contains only one test, the one generated by the Spring initializer. We agree that it is logically impossible for a test to ensure that no bugs are present. It allows us to verify at least that the application does what it should do. In this case, without tests, this minimum is not guaranteed and any re-factorisation is therefore inadvisable since any regression could not be identified. For an existing project where there is a lack of testing it is possible to start with component testing to cover as much code as possible;\nLack of settings and CI(CD) CI/CD, Continuous Integration and Continuous Deployment, is an essential element in monitoring the functionality of code. Among other things, it allows:\n to build the code to launch the tests by distinguishing the tests by type run tests for code quality with plugins like Checkstyle or Spotless check the coverage of the code create Docker images to deploy the api on a given environment  The CI/CD can be launched after a push to a branch, the creation of the pull request (or merge request), the merge on the reference branch.\nLack of tools to check the quality of the code. The quality of the code can be defined by its readability and the respect of programming rules (whether they are specific to the company or defined with a tool such as SonarQube). The code review is there to validate these points, but it can be facilitated by the implementation of tools such as:\n the use of plugins (Maven or Gradle) like Checkstyle which will be launched during builds the use of a style code (like google-java-format or Spotless) in the IDE to ensure proper formatting Using a plugin such as SonarLint to check the quality of the code against the company\u0026rsquo;s quality gates  Architectural problems Use of a H2 database The first point is more of an oversight on our part when creating the basic application: it is the use of the H2 database and not the use of a database like Postgresql or Mysql. It goes without saying that the use of an embedded database is not compatible with the use of an application (API) in production.\nUse of a layered architecture \\ the use of a layered architecture favours database-based modelling. This prevents :\n parallelize development: entities and repositories must be created for this to work. The database schema is often used as the basis for the business model  Mix of business domains Looking at the code, it appears that the different business lines: people management, forms management and notes management are all linked. This mixture of functions reduces the robustness of the code; the greater the number of functions, the greater the number of reasons to change the code and therefore the greater the risk of regressions. The application of the \u0026ldquo;single responsibility\u0026rdquo; principle would already allow splitting some classes\nUpcoming articles The issues identified in this article will be the subject of a series of articles that will outline how to correct them and enable us to improve our API. The first articles will cover, among other things\n The implementation of tests Setting up a hexagonal architecture with ArchUnit Setting up SonarQube The implementation of quality and correction of the code smell  If you are reading this sentence, it means that you have read this article in its entirety, and I thank you for that because this is my first article. If you have any remarks on the content or the form, you can leave a comment\u0026hellip;it is by exchanging that we progress.\nWritten by : Emmanuel Quinton Review by : Daniele Cremonini\n","date":"15-01-2023","img":"","permalink":"/en/posts/how-to-evolve-application-presentation/","series":["How to evolve an application to make it more robust and maintainable"],"tags":[""],"title":"How to Evolve an Application to Make It More Robust and Maintainable - Presentation"},{"categories":["quality","test"],"content":"How to evolve an application to make it more robust and maintainable - Setting up the test Foreword In the introductory article of this series (link) we presented the different problems of our application (add link). The first one I propose to solve in this article is the addition of tests. The purpose of adding tests is not only to increasing the code coveragecover the code and pass a quality gate; it is there to validate the business rules and allow refactoring with less risk. In this article we will look at how to add tests to an application that does not have any. We will discuss unit tests, integration tests and system tests\nDefinitions of the different types of tests A unit test is a test that only checks the method of a class or a class. External classes, often called \u0026ldquo;collaborators\u0026rdquo;, that might be called will be mocked. We will place unit tests mainly on services that must contain business code, i.e. code with added value. An integration test is a test that aims to verify the correct integration of certain parts of a process and not the process as a whole. We will concentrate our integration tests on endpoints and repositories. A system test is a black-box test that verifies that the entire use case works.\nIn a case such as that of our application, where no tests exist, it is preferable to start with a system test to quickly verify the correct operation and non-regression of a functionality, and then to increase the unit tests and integration tests.\nUnit testing Since our application is in Java we will use as libraries for the tests: Junit5, Mockito and AssertJ.\nSetting up the test The dependencies are to be added in the build.gradle but for readability reasons I prefer to create a unit-test.gradle file which will contain all the necessary configurations. This file is called by the build.gradle file\nLocation of the unit-test.gradle file\nContents of the unit-test.gradle file\n1dependencies { 2 3 testImplementation group: \u0026#39;org.junit.jupiter\u0026#39;, name: \u0026#39;junit-jupiter\u0026#39;, version: \u0026#39;5.8.2\u0026#39; 4 testImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-junit-jupiter\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 5 testImplementation group: \u0026#39;org.assertj\u0026#39;, name: \u0026#39;assertj-core\u0026#39;, version: \u0026#39;3.21.0\u0026#39; 6 testImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 7} 8 In the build.gradle file\n1apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; Implementation of a test The rules for writing a unit test :\n Each test must be created in the test directory Each test class is in the same package as the class it tests The names of the test methods are in snack_case ( (cf https://en.wikipedia.org/wiki/Snake_case ) The number of things tested should be limited, ideally to 1.  Example of a test 1 2@Test 3void should_add_question_to_form() { 4 // given 5 var formId = UUID.fromString(\u0026#34;18b8f2e2-f41c-4ca4-a007-c328390cd099\u0026#34;); 6 var savedForm = new Form(); 7 var existingQuestion = new QuestionAnswer(formId, \u0026#34;What is your first name\u0026#34;, null, savedForm); 8 var questions = new HashSet\u0026lt;QuestionAnswer\u0026gt;(); 9 questions.add(existingQuestion); 10 savedForm.setQuestions(questions); 11 savedForm.setId(formId); 12 13 BDDMockito.when(formRepository.getById(formId)).thenReturn(savedForm); 14 15 var questionToSave = 16 new QuestionAnswer(null, \u0026#34;What is your objectives for the next year\u0026#34;, null, null); 17 18 // when 19 formService.createQuestion(formId, questionToSave); 20 21 // then 22 var questionAnswerArgumentCaptor = ArgumentCaptor.forClass(QuestionAnswer.class); 23 24 BDDMockito.then(questionAnswerRepository).should().save(questionAnswerArgumentCaptor.capture()); 25 var actualQuestions = questionAnswerArgumentCaptor.getValue(); 26 BDDSoftAssertions.thenSoftly( 27 softly -\u0026gt; { 28 softly.then(actualQuestions).isNotNull(); 29 softly.then(actualQuestions) 30 .extracting(\u0026#34;form.questions\u0026#34;, Assertions.as(InstanceOfAssertFactories.COLLECTION)) 31 .hasSize(2); 32 }); 33} 34 Code details The most important points are\n The use of mocks to simulate the behaviour of methods of other classes that are called  1BDDMockito.when(formRepository.getById(formId)).thenReturn(savedForm); 2  The use of ArgumentCaptor to catch and then validate the form passed to the save method of the repository  1 var questionAnswerArgumentCaptor = ArgumentCaptor.forClass(QuestionAnswer.class); 2 3 BDDMockito.then(questionAnswerRepository).should().save(questionAnswerArgumentCaptor.capture()); 4 var actualQuestions = questionAnswerArgumentCaptor.getValue(); 5  The use of SoftAssertions to be able to check several things. Unlike validation via the Assertions class, which will raise an error on the first error, SoftAssertions will test all conditions and raise errors afterwards.  1 BDDSoftAssertions.thenSoftly( 2 softly -\u0026gt; { 3 softly.then(actualQuestions).isNotNull(); 4 softly.then(actualQuestions) 5 .extracting(\u0026#34;form.questions\u0026#34;, Assertions.as(InstanceOfAssertFactories.COLLECTION)) 6 .hasSize(2); 7 }); Integration testing Setting up the test To set up the integration tests we will create a directory at the same level as the test and main directories.\nThe separation of unit tests and integration tests has the advantage of allowing us to distinguish which type of tests we want to run and when; this will be useful when setting up the CI/CD. The configuration will be done in the same way as for unit tests via a separate gradle file.\nLocation of the integration-test.gradle file\nContent of the integration-test.gradle file\n1sourceSets { 2 integrationTest { 3 java { 4 compileClasspath += sourceSets.main.output 5 runtimeClasspath += sourceSets.main.output 6 srcDir file(\u0026#39;src/integration-test/java\u0026#39;) 7 } 8 resources.srcDir file(\u0026#39;src/integration-test/resources\u0026#39;) 9 } 10} 11 12configurations { 13 integrationTestImplementation.extendsFrom implementation 14 integrationTestRuntimeOnly.extendsFrom runtimeOnly 15} 16 17dependencies { 18 integrationTestImplementation group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-test\u0026#39; 19 integrationTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 20 integrationTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-inline\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 21} 22 23tasks.register(\u0026#39;integrationTest\u0026#39;, Test) { 24 description = \u0026#39;Runs integration tests.\u0026#39; 25 group = \u0026#39;verification\u0026#39; 26 27 testClassesDirs = sourceSets.integrationTest.output.classesDirs 28 classpath = sourceSets.integrationTest.runtimeClasspath 29 shouldRunAfter test 30 useJUnitPlatform() 31} 32 33check.dependsOn integrationTest Dans le fichier build.gradle\n1apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; 2apply from: \u0026#34;gradle/integration-test.gradle\u0026#34; 3 Implementation of a test As the integration tests takeare longer, we will limit them to controllers and repositories; services, as we have seen above, are tested by unit tests. At the level of controllers, the objectives will be to verify that the endpoints respond correctly, i.e. we will verify :\n the validity status returned. error feedback due to invalid parameters or in the body of the request  The services called in the controllers will be mocked, and the calls to the service methods can be validated. This way of testing makes us understand why it is necessary to limit the business code in the controllers. At the repository level, we will check the validity of the requests, concentrating initially on the most complex requests.\nExample of a controller integration test\n1@WebMvcTest(controllers = InterviewController.class) 2public class InterviewControllerITest { 3 4 @Autowired Jackson2ObjectMapperBuilder mapperBuilder; 5 6 @Autowired private MockMvc mockMvc; 7 8 @MockBean private InterviewService interviewService; 9 10 @Test 11 @DisplayName(\u0026#34;Should get all interviews\u0026#34;) 12 void should_get_persons() throws Exception { 13 // when 14 mockMvc 15 .perform( 16 MockMvcRequestBuilders.get(\u0026#34;/interviews\u0026#34;) 17 .contentType(MediaType.APPLICATION_JSON) 18 .accept(MediaType.APPLICATION_JSON)) 19 .andExpect(MockMvcResultMatchers.status().isOk()); 20 21 // then 22 BDDMockito.then(interviewService).should().findAll(); 23 } 24 25 Example of a repository integration test\n1 2@DataJpaTest 3@ActiveProfiles(\u0026#34;it\u0026#34;) 4public class FormRepositoryITest { 5 @Autowired 6 private FormRepository formRepository; 7 8 @Test 9 void should_create_form() { 10 // given 11 var questionAnswer = new QuestionAnswer(null, \u0026#34;What do you think about your work this year\u0026#34;, null, null); 12 var formToSave = new Form(null, Set.of(questionAnswer)); 13 14 // when 15 var actualForm = formRepository.save(formToSave); 16 17 // then 18 var idNotNull = new Condition\u0026lt;Form\u0026gt;((Form form) -\u0026gt; form.getId() != null, \u0026#34;form id not null\u0026#34;); 19 var asOneQuestion = new Condition\u0026lt;Form\u0026gt;((Form form) -\u0026gt; form.getQuestions().size() == 1, \u0026#34;form has only one question\u0026#34;); 20 BDDAssertions.then(actualForm) 21 .as(\u0026#34;Check if a new form has been saved.\u0026#34;) 22 .has(idNotNull) 23 .has(asOneQuestion); 24 } 25 26 Code details end-point testing For endpoint tests we annotate the test classes with @WebMvcTest, which allows us to load a minimal environment in order to test only the controller defined in the annotation.\n1@WebMvcTest(controllers = InterviewController.class) The spring MockMvc class allows endpoint testing without loading the entire application context.\n1 mockMvc 2 .perform( 3 MockMvcRequestBuilders.get(\u0026#34;/interviews\u0026#34;) 4 .contentType(MediaType.APPLICATION_JSON) 5 .accept(MediaType.APPLICATION_JSON)) 6 .andExpect(MockMvcResultMatchers.status().isOk()); In order to test only the endpoint (return code, returned object \u0026hellip;) we mock the service which is called with the @MockBean annotation of Sspring\n1 @MockBean private InterviewService interviewService; Repositories testing Integration tests between a repository and the database are done with the @DataJpaTest annotation   When testing the registration of an object, it is possible to check the generated identifier of the object in return For methods like find, findAll, findId we can use the @Sql annotation to populate the database before testing. This is useful when the database at startup is empty. Here I have not done this but it is quite possible to start the tests with a pre-initialised database.\n1@Sql(scripts = {\u0026#34;/sql_scripts/initialize_form.sql\u0026#34;} ) System testing Setting up the test As with the integration tests, the system tests are in a separate directory; the configuration is in the file system-test.gradle.\nLocation of the system-test.gradle file\nContents of the system-test.gradle file\n1sourceSets { 2 systemTest { 3 java { 4 compileClasspath += sourceSets.main.output 5 runtimeClasspath += sourceSets.main.output 6 srcDir file(\u0026#39;src/system-test/java\u0026#39;) 7 } 8 resources.srcDir file(\u0026#39;src/system-test/resources\u0026#39;) 9 } 10} 11 12configurations { 13 systemTestImplementation.extendsFrom implementation 14 systemTestRuntimeOnly.extendsFrom runtimeOnly 15} 16 17dependencies { 18 systemTestImplementation group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-test\u0026#39; 19 systemTestImplementation group: \u0026#39;io.rest-assured\u0026#39;, name: \u0026#39;rest-assured\u0026#39;, version: \u0026#39;4.4.0\u0026#39; 20 systemTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-core\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 21 systemTestImplementation group: \u0026#39;org.mockito\u0026#39;, name: \u0026#39;mockito-inline\u0026#39;, version: \u0026#39;4.2.0\u0026#39; 22 23 24} 25 In the build.gradle file\n1 2apply from: \u0026#34;gradle/unit-test.gradle\u0026#34; 3apply from: \u0026#34;gradle/integration-test.gradle\u0026#34; 4apply from: \u0026#34;gradle/system-test.gradle\u0026#34; 5 6systemTest { 7 shouldRunAfter integrationTest 8} 9 Implementation of a test 1 2@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 3class PostInterviewTest { 4 @Autowired Jackson2ObjectMapperBuilder mapperBuilder; 5 6 @LocalServerPort 7 8 private Integer port; 9 10 @BeforeAll 11 public static void setup() { 12 RestAssured.baseURI = \u0026#34;http://localhost\u0026#34;; 13 } 14 @Test 15 @Sql(scripts = \u0026#34;/sql_scripts/init_database.sql\u0026#34;) 16 void should_create_interview() throws JsonProcessingException { 17 var manager = 18 new Person(UUID.fromString(\u0026#34;8a37adbc-0c29-491a-8b6f-f10a4219fb91\u0026#34;), null, null, true); 19 var employee = 20 new Person(UUID.fromString(\u0026#34;3556c835-3bcd-420e-bb6e-a8b7c0bb139d\u0026#34;), null, null, false); 21 var form = new Form(UUID.fromString(\u0026#34;df9b2aad-d32e-469e-b434-be71a5531a35\u0026#34;), new HashSet\u0026lt;\u0026gt;()); 22 var interview = new Interview(null, Instant.now(), manager, employee, form); 23 24 RestAssured.given() 25 .header(\u0026#34;Content-type\u0026#34;, \u0026#34;application/json\u0026#34;) 26 .and() 27 .port(port) 28 .body(mapperBuilder.build().writeValueAsString(interview)) 29 .when() 30 .post(\u0026#34;/interviews\u0026#34;) 31 .then() 32 .statusCode(HttpStatus.SC_CREATED); 33 } 34} 35 Code details The points to note in this test are:\n The use of the SpringBootTest annotation to load the entire spring context. The use of RestAssured to test endpoints.  Summary  There are three types of test bases: unit tests which test a method and only the content of the method, integration tests which validate the correct integration between two layers (endpoint calls, repository/database connections) and finally system tests which validate the correct operation of a functionality. For an existing API without tests, it is possible to start by setting up system tests on the most critical endpoints and then gradually adding integration and unit tests. For a new API it is best to start with unit testing and progress to system testing  If you have any comments on the content, the form you can leave a comment\u0026hellip;it is by exchanging that we progress.\nAuthor : Emmanuel Quinton Reviewer : Daniele Cremonini\n","date":"09-01-2023","img":"","permalink":"/en/posts/how-to-evolve-application-tests/","series":[" How to evolve an application to make it more robust and maintainable"],"tags":[""],"title":"How to Evolve an Application to Make It More Robust and Maintainable - Setting Up the Test"},{"categories":[""],"content":"Can an AutoFormat Tool Increase Productivity?\nThe answer is yes.\nThe book “The Pragmatic Programmer” talks about the entropy of the code. Entropy is a physical quantity linked to molecular disorder. This is perhaps the only physical quantity that we can find in software. The larger the disorder, the higher the entropy. The more entropic your software is, the harder it will be to work with it day by day.\nTo explain why, I\u0026rsquo;ll give you an example.\nWhen writing an if-then-else in a language like Java where is it better to put parentheses?\nYou can say how a), b) or c) or you can invent another intermediate combination of your taste.\na)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} else { 4 // your \u0026#34;else\u0026#34; code here 5} b)\n1if (condition) 2{ 3 // your \u0026#34;then\u0026#34; code here 4} 5else 6{ 7 // your \u0026#34;else\u0026#34; code here 8} c)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} 4else { 5 // your \u0026#34;else\u0026#34; code here 6} The ways to format the code are numerous: where to put the opening of the brace, whether to use the TAB or the space to indent, whether to add a space after the opening of a round bracket, where to put the comments. Even the writing of the logical conditions can be done in many ways:\n1(a==b) or\n1(a == b) or\n1( a == b ) I have witnessed several heated discussions on which style is \u0026ldquo;better\u0026rdquo; but beyond what can come out of them, what really matters most is consistency. Why? Because, depending on how much a person may not like a certain style, after a while they will adjust to it, and the reading of the code will become automatic. The code becomes more intuitive. If the formatting of the code is inconsistent, reading the code becomes more strenuous. Fatigue increases the likelihood of making mistakes. It will take time to find these errors and more time to correct them. Ultimately, not formatting your code consistently results in a decline in productivity.\nKeeping your code formatted consistently can be a challenge for even a single developer but in a team, you can rest assured that consistency won\u0026rsquo;t last. Developers almost always work as a team. For a team, having a shared rule means increasing overall productivity.\nTry to reach a consensus about the formatting style, and if you can’t reach the consensus, just impose one.\nEven if you encounter some resistance at first, your colleagues will get used to it, will tire less and will be more productive.\nConsistency and the resulting order are even more important than the style of the formatting itself.\nIf we have a tool that not only verifies that the rules are respected but also formats the code automatically, we get a second big advantage which is to save time and stress to apply the formatting.\nThe definition of a formatting style for a language with an average complex syntax such as that of Java can require dozens of rules and for what has been said above, it is good that these rules are consistent in the various cases that may arise.\nWhat happens if you decide to apply formatting rules to a project that is made up of several files? Do you have to format all files in one go or is it better to proceed gradually by formatting only a few files at a time?\nIf a project has a history of a few days, formatting all the files in one go does not have a big impact on the traceability of changes in the log of the source management system (git for example) but if the files are hundreds with more developers than they work and maybe in asynchronous mode (as usually happens on an open source project) applying the formatting little by little is really a necessity.\nFinally, since it is better not to have to worry every time you tap on the code to format it, it is better to have an automatic activation of the formatting.\nThen you need to create a software tool that reads the code, applies the rules, and make it possible that it runs at every build.\nDo you want to know how we did all these things in our Happraisal application?\nWe have chosen a ready-made solution. In the open source world there are some. We chose Spotless because in addition to allowing us to analyze the code and format it, it is also multilingual. Spotless is not limited to Java but also handles C, JavaScript, TypeScript, yaml, JSON, SQL and others.\nThe Spotless repository is on GitHub: https://github.com/diffplug/spotless Spotless can be integrated into Maven and Gradle based builds via plugins.\nTo use Spotless in Happraisal we imported a plugin into Gradle and further down we included a configuration file via the apply command:\nbuild.gradle\n1plugins { 2 // other plugins 3 id \u0026#34;com.diffplug.spotless\u0026#34; version \u0026#34;6.2.1\u0026#34; 4} 5 6// Include the configuration for Spotless 7apply from: \u0026#34;gradle / spotless.gradle\u0026#34; Our gradle/spotless.gradle consists of three parts. The first is ratchetFrom which, if specified, allows you to apply formatting incrementally only to files modified with respect to the specified branch, which in the case of Happraisal to origin/develop because this is the branch towards which merge requests flow. Basically, every time we add code to origin/develop, Spotless forces us not to make the situation worse. The parameter specified in ratchetFrom can be something more complicated, to learn more you can consult this file: https://javadoc.io/static/org.eclipse.jgit/org.eclipse.jgit/5.6.1.202002131546-r/org/eclipse/jgit/lib/Repository.html#resolve-java.lang.String- Linguistic note: The word ratchet in English means that the rule can be more stringent (or remain unchanged) but cannot become less stringent.\nThe second section called “misc” allows you to specify formatting rules for files that can be identified through the extension gradle or md.\nThe third section is dedicated to Java. In the Java section there is a call to googleJavaFormat which is an application dedicated exclusively to the formatting of Java code.\nGoogle Java Format can be found on GitHub: https://github.com/google/google-java-format and in the tags you will find all the published versions (for example 1.13).\nIf you don\u0026rsquo;t like the formatting style imposed by Google and want to orient yourself on a configurable style then you need to switch to an Eclipse formatter. I refer you to the Spotless website for further information.\nNote that Spotless also allows you to manage headers for software licenses via the licenseHeader command.\n1spotless { 2// optional: limit format enforcement to just the files changed by this feature branch 3ratchet From \u0026#39;origin/develop\u0026#39; 4 5 format \u0026#39;misc\u0026#39;, { 6 // define the files to apply `misc` to 7 target \u0026#39;* .gradle\u0026#39;, \u0026#39;* .md \u0026#39;,\u0026#39; .gitignore \u0026#39; 8 9 // define the steps to apply to those files 10 trimTrailingWhitespace () 11 indentWithSpaces () // tab or spaces. indentWithSpaces takes an integer argument, the default value is 4 12 endWithNewline () 13 } 14 15 java { 16 // don\u0026#39;t need to set target, it is inferred from Java 17 18 // apply a specific flavor of google-java-format 19 googleJavaFormat (\u0026#39;1.13. 0 \u0026#39;). ReflowLongStrings () 20 // make sure every file has the following copyright header. 21 // optionally, Spotless can set copyright years by digging 22 // through git history. 23 licenseHeader \u0026#39;/ * (C) $ YEAR * /\u0026#39; 24 } 25} Summary Applying strict rules to code formatting reduces the effort and the stress of developers and increases their productivity. It would be better to share a formatting style on a team level but if you don\u0026rsquo;t get there by consensus, it\u0026rsquo;s worth enforcing it because after a while people get used to it. Once you\u0026rsquo;ve decided on a style, it\u0026rsquo;s good to have an automated tool to check that the formatting is consistent. Having a tool to apply formatting automatically saves time and eliminates a mechanical task. Spotless is an open source tool that can be integrated via plugins with Maven and Gradle. Spotless allows you to format your code gradually so you don\u0026rsquo;t have to make a mega commit at the time of its introduction.\nIf you are reading this sentence, it’s because you read the whole article. Thank you because this is my first article. If you have any comment on this content or on the format, please leave a comment…\nIt\u0026rsquo;s by sharing ideas that we progress!\n Author: Daniele Cremonini Reviewer: Emmanuel Quinton ","date":"17-10-2022","img":"","permalink":"/en/posts/what-is-code-formatting-and-why-does-it-matter/","series":["Tools for Java"],"tags":[""],"title":"What Is Code Formatting and Why Does It Matter"},{"categories":null,"content":"Have you ever gotten stuck while writing a particularly complicated piece of code and figured out what was wrong at the exact moment you asked a colleague for help?\nExplain your code to a duck (if it\u0026rsquo;s made of rubber, it will always remain handy on your desk) and your ideas will catch on quickly.\nIt may seem strange but if instead of reading the code over and over, you tell someone about it, your brain often reveals the mystery. The idea of ​​explaining the code to a rubber duck was popularized by the book \u0026ldquo;The Pragmatic Programmer\u0026rdquo;. The method works. This explains the logo.\nBut, what prompted us to create a site that encourages you to talk to a duck? We made several observations:\n We often come across code that is not updated with respect to the article that explains it In many cases, the projects associated with the articles do not have tests. The quality of the code is a little known or neglected argument in favor of different factors that are almost never justifiable in rational terms.  The main idea of this site is therefore to present articles and methodologies which will be associated with projects with the same quality that is required of us in our work and to keep them up-to-date.\nBy extension, the idea is also to present articles about our job as developers and maybe even to present some books that we particularly liked.\nThe arguments reflect only our opinions and our way of doing but it is always our point of view and we are willing to change them because to progress you need to know how to listen and understand the opinion of others and accept that there are different ways of doing.\n","date":"13-01-2022","img":"","permalink":"/en/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"","date":"04-01-2022","img":"","permalink":"/en/offline/","series":null,"tags":null,"title":"Offline"},{"categories":null,"content":"render = never\n+++ title = \u0026ldquo;Contact Us\u0026rdquo; layout = \u0026ldquo;contact\u0026rdquo; [menu.footer] parent = \u0026ldquo;support\u0026rdquo; weight = 6 pre = \u0026lsquo;\u0026rsquo; +++\n","date":"01-01-0001","img":"","permalink":"/en/contact/","series":null,"tags":null,"title":""},{"categories":null,"content":"render = never\n+++ title = \u0026ldquo;FAQs\u0026rdquo; description = \u0026ldquo;Frequently Asked Questions\u0026rdquo; layout = \u0026ldquo;faq\u0026rdquo; [menu.main] parent = \u0026ldquo;support\u0026rdquo; weight = 6 [menu.footer] parent = \u0026ldquo;support\u0026rdquo; weight = 6 pre = \u0026lsquo;\u0026rsquo; +++\n","date":"01-01-0001","img":"","permalink":"/en/faq/","series":null,"tags":null,"title":""}]
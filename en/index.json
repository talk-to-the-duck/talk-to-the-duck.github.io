[{"categories":[""],"content":"Can an AutoFormat Tool Increase Productivity?\nThe answer is yes.\nThe book “The Pragmatic Programmer” talks about the entropy of the code. Entropy is a physical quantity linked to molecular disorder. This is perhaps the only physical quantity that we can find in software. The larger the disorder, the higher the entropy. The more entropic your software is, the harder it will be to work with it day by day.\nTo explain why, I\u0026rsquo;ll give you an example.\nWhen writing an if-then-else in a language like Java where is it better to put parentheses?\nYou can say how a), b) or c) or you can invent another intermediate combination of your taste.\na)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} else { 4 // your \u0026#34;else\u0026#34; code here 5} b)\n1if (condition) 2{ 3 // your \u0026#34;then\u0026#34; code here 4} 5else 6{ 7 // your \u0026#34;else\u0026#34; code here 8} c)\n1if (condition) { 2 // your \u0026#34;then\u0026#34; code here 3} 4else { 5 // your \u0026#34;else\u0026#34; code here 6} The ways to format the code are numerous: where to put the opening of the brace, whether to use the TAB or the space to indent, whether to add a space after the opening of a round bracket, where to put the comments. Even the writing of the logical conditions can be done in many ways:\n1(a==b) or\n1(a == b) or\n1( a == b ) I have witnessed several heated discussions on which style is \u0026ldquo;better\u0026rdquo; but beyond what can come out of them, what really matters most is consistency. Why? Because, depending on how much a person may not like a certain style, after a while they will adjust to it, and the reading of the code will become automatic. The code becomes more intuitive. If the formatting of the code is inconsistent, reading the code becomes more strenuous. Fatigue increases the likelihood of making mistakes. It will take time to find these errors and more time to correct them. Ultimately, not formatting your code consistently results in a decline in productivity.\nKeeping your code formatted consistently can be a challenge for even a single developer but in a team, you can rest assured that consistency won\u0026rsquo;t last. Developers almost always work as a team. For a team, having a shared rule means increasing overall productivity.\nTry to reach a consensus about the formatting style, and if you can’t reach the consensus, just impose one.\nEven if you encounter some resistance at first, your colleagues will get used to it, will tire less and will be more productive.\nConsistency and the resulting order are even more important than the style of the formatting itself.\nIf we have a tool that not only verifies that the rules are respected but also formats the code automatically, we get a second big advantage which is to save time and stress to apply the formatting.\nThe definition of a formatting style for a language with an average complex syntax such as that of Java can require dozens of rules and for what has been said above, it is good that these rules are consistent in the various cases that may arise.\nWhat happens if you decide to apply formatting rules to a project that is made up of several files? Do you have to format all files in one go or is it better to proceed gradually by formatting only a few files at a time?\nIf a project has a history of a few days, formatting all the files in one go does not have a big impact on the traceability of changes in the log of the source management system (git for example) but if the files are hundreds with more developers than they work and maybe in asynchronous mode (as usually happens on an open source project) applying the formatting little by little is really a necessity.\nFinally, since it is better not to have to worry every time you tap on the code to format it, it is better to have an automatic activation of the formatting.\nThen you need to create a software tool that reads the code, applies the rules, and make it possible that it runs at every build.\nDo you want to know how we did all these things in our Happraisal application?\nWe have chosen a ready-made solution. In the open source world there are some. We chose Spotless because in addition to allowing us to analyze the code and format it, it is also multilingual. Spotless is not limited to Java but also handles C, JavaScript, TypeScript, yaml, JSON, SQL and others.\nThe Spotless repository is on GitHub: https://github.com/diffplug/spotless Spotless can be integrated into Maven and Gradle based builds via plugins.\nTo use Spotless in Happraisal we imported a plugin into Gradle and further down we included a configuration file via the apply command:\nbuild.gradle\n1plugins { 2 // other plugins 3 id \u0026#34;com.diffplug.spotless\u0026#34; version \u0026#34;6.2.1\u0026#34; 4} 5 6// Include the configuration for Spotless 7apply from: \u0026#34;gradle / spotless.gradle\u0026#34; Our gradle/spotless.gradle consists of three parts. The first is ratchetFrom which, if specified, allows you to apply formatting incrementally only to files modified with respect to the specified branch, which in the case of Happraisal to origin/develop because this is the branch towards which merge requests flow. Basically, every time we add code to origin/develop, Spotless forces us not to make the situation worse. The parameter specified in ratchetFrom can be something more complicated, to learn more you can consult this file: https://javadoc.io/static/org.eclipse.jgit/org.eclipse.jgit/5.6.1.202002131546-r/org/eclipse/jgit/lib/Repository.html#resolve-java.lang.String- Linguistic note: The word ratchet in English means that the rule can be more stringent (or remain unchanged) but cannot become less stringent.\nThe second section called “misc” allows you to specify formatting rules for files that can be identified through the extension gradle or md.\nThe third section is dedicated to Java. In the Java section there is a call to googleJavaFormat which is an application dedicated exclusively to the formatting of Java code.\nGoogle Java Format can be found on GitHub: https://github.com/google/google-java-format and in the tags you will find all the published versions (for example 1.13).\nIf you don\u0026rsquo;t like the formatting style imposed by Google and want to orient yourself on a configurable style then you need to switch to an Eclipse formatter. I refer you to the Spotless website for further information.\nNote that Spotless also allows you to manage headers for software licenses via the licenseHeader command.\n1spotless { 2// optional: limit format enforcement to just the files changed by this feature branch 3ratchet From \u0026#39;origin/develop\u0026#39; 4 5 format \u0026#39;misc\u0026#39;, { 6 // define the files to apply `misc` to 7 target \u0026#39;* .gradle\u0026#39;, \u0026#39;* .md \u0026#39;,\u0026#39; .gitignore \u0026#39; 8 9 // define the steps to apply to those files 10 trimTrailingWhitespace () 11 indentWithSpaces () // tab or spaces. indentWithSpaces takes an integer argument, the default value is 4 12 endWithNewline () 13 } 14 15 java { 16 // don\u0026#39;t need to set target, it is inferred from Java 17 18 // apply a specific flavor of google-java-format 19 googleJavaFormat (\u0026#39;1.13. 0 \u0026#39;). ReflowLongStrings () 20 // make sure every file has the following copyright header. 21 // optionally, Spotless can set copyright years by digging 22 // through git history. 23 licenseHeader \u0026#39;/ * (C) $ YEAR * /\u0026#39; 24 } 25} Summary Applying strict rules to code formatting reduces the effort and the stress of developers and increases their productivity. It would be better to share a formatting style on a team level but if you don\u0026rsquo;t get there by consensus, it\u0026rsquo;s worth enforcing it because after a while people get used to it. Once you\u0026rsquo;ve decided on a style, it\u0026rsquo;s good to have an automated tool to check that the formatting is consistent. Having a tool to apply formatting automatically saves time and eliminates a mechanical task. Spotless is an open source tool that can be integrated via plugins with Maven and Gradle. Spotless allows you to format your code gradually so you don\u0026rsquo;t have to make a mega commit at the time of its introduction.\nIf you are reading this sentence, it’s because you read the whole article. Thank you because this is my first article. If you have any comment on this content or on the format, please leave a comment…\nIt\u0026rsquo;s by sharing ideas that we progress!\n Author: Daniele Cremonini Reviewer: Emmanuel Quinton ","date":"12-10-2022","img":"","permalink":"/en/posts/what-is-code-formatting-and-why-does-it-matter/","series":["Tools for Java"],"tags":[""],"title":"What Is Code Formatting and Why Does It Matter"},{"categories":["quality"],"content":"How to evolve an application to make it more robust and maintainable - Presentation Foreword Recently I was shown an application that had been created quite recently but which looked like an application from ten or fifteen years ago. After that I thought it would be interesting to try to make an application similar to the one I was shown evolve towards a quality architecture. Through this first article we will present the application (cf link to GitHub) for which we will make a state of the art, and we will define the axes of improvement that we will set up in the next articles of this series.\nPresentation of the application Functionally The API allows to manage interviews between a manager and his mentees. The management rules are:\nAn interview:\n concerns a manager and an employee. has a form  A form:\n has a simple answer to each question. An answer can be entered in a text field. can be associated with a note that only the manager can see  A manager\n can create an interview can create a note visible only to him/her  Technically The application is written in java 11, it was generated by the Spring initilaizer (). The database is H2 (problem that we will fix quickly)\nThe problems A quick look at the code shows several types of problems:\n documentation problems quality problems architecture problems  Documentation problems an empty readme By convention the README is the entry point to any application; it should allow newcomers to understand, launch and test the application. It should therefore contain in addition to a quick presentation of the API\n Instructions for compiling the code Instructions for running the application locally Data to use locally if needed  no swagger (or other) In order to test an API easily it is necessary to have a tool to run queries, which can range from Postman scripts to a fully integrated Swagger.\nQuality problems no tests The project contains only one test, the one generated by the Spring initializer. We agree that it is logically impossible for a test to ensure that no bugs are present. It allows us to verify at least that the application does what it should do. In this case, without tests, this minimum is not guaranteed and any re-factorisation is therefore inadvisable since any regression could not be identified. For an existing project where there is a lack of testing it is possible to start with component testing to cover as much code as possible;\nLack of settings and CI(CD) CI/CD, Continuous Integration and Continuous Deployment, is an essential element in monitoring the functionality of code. Among other things, it allows:\n to build the code to launch the tests by distinguishing the tests by type run tests for code quality with plugins like Checkstyle or Spotless check the coverage of the code create Docker images to deploy the api on a given environment  The CI/CD can be launched after a push to a branch, the creation of the pull request (or merge request), the merge on the reference branch.\nLack of tools to check the quality of the code. The quality of the code can be defined by its readability and the respect of programming rules (whether they are specific to the company or defined with a tool such as SonarQube). The code review is there to validate these points, but it can be facilitated by the implementation of tools such as:\n the use of plugins (Maven or Gradle) like Checkstyle which will be launched during builds the use of a style code (like google-java-format or Spotless) in the IDE to ensure proper formatting Using a plugin such as SonarLint to check the quality of the code against the company\u0026rsquo;s quality gates  Architectural problems Use of a H2 database The first point is more of an oversight on our part when creating the basic application: it is the use of the H2 database and not the use of a database like Postgresql or Mysql. It goes without saying that the use of an embedded database is not compatible with the use of an application (API) in production.\nUse of a layered architecture \\ the use of a layered architecture favours database-based modelling. This prevents :\n parallelize development: entities and repositories must be created for this to work. The database schema is often used as the basis for the business model  Mix of business domains Looking at the code, it appears that the different business lines: people management, forms management and notes management are all linked. This mixture of functions reduces the robustness of the code; the greater the number of functions, the greater the number of reasons to change the code and therefore the greater the risk of regressions. The application of the \u0026ldquo;single responsibility\u0026rdquo; principle would already allow splitting some classes\nUpcoming articles The issues identified in this article will be the subject of a series of articles that will outline how to correct them and enable us to improve our API. The first articles will cover, among other things\n The implementation of tests Setting up a hexagonal architecture with ArchUnit Setting up SonarQube The implementation of quality and correction of the code smell  If you are reading this sentence, it means that you have read this article in its entirety, and I thank you for that because this is my first article. If you have any remarks on the content or the form, you can leave a comment\u0026hellip;it is by exchanging that we progress.\nWritten by : Emmanuel Quinton Review by : Daniele Cremonini\n","date":"18-02-2022","img":"","permalink":"/en/posts/how-to-evolve-application-presentation/","series":["How to evolve an application to make it more robust and maintainable"],"tags":[""],"title":"How to Evolve an Application to Make It More Robust and Maintainable - Presentation"},{"categories":null,"content":"Have you ever gotten stuck while writing a particularly complicated piece of code and figured out what was wrong at the exact moment you asked a colleague for help?\nExplain your code to a duck (if it\u0026rsquo;s made of rubber, it will always remain handy on your desk) and your ideas will catch on quickly.\nIt may seem strange but if instead of reading the code over and over, you tell someone about it, your brain often reveals the mystery. The idea of ​​explaining the code to a rubber duck was popularized by the book \u0026ldquo;The Pragmatic Programmer\u0026rdquo;. The method works. This explains the logo.\nBut, what prompted us to create a site that encourages you to talk to a duck? We made several observations:\n We often come across code that is not updated with respect to the article that explains it In many cases, the projects associated with the articles do not have tests. The quality of the code is a little known or neglected argument in favor of different factors that are almost never justifiable in rational terms.  The main idea of this site is therefore to present articles and methodologies which will be associated with projects with the same quality that is required of us in our work and to keep them up-to-date.\nBy extension, the idea is also to present articles about our job as developers and maybe even to present some books that we particularly liked.\nThe arguments reflect only our opinions and our way of doing but it is always our point of view and we are willing to change them because to progress you need to know how to listen and understand the opinion of others and accept that there are different ways of doing.\n","date":"28-02-2019","img":"","permalink":"/en/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"render = never\n+++ title = \u0026ldquo;Contact Us\u0026rdquo; layout = \u0026ldquo;contact\u0026rdquo; [menu.footer] parent = \u0026ldquo;support\u0026rdquo; weight = 6 pre = \u0026lsquo;\u0026rsquo; +++\n","date":"01-01-0001","img":"","permalink":"/en/contact/","series":null,"tags":null,"title":""},{"categories":null,"content":"render = never\n+++ title = \u0026ldquo;FAQs\u0026rdquo; description = \u0026ldquo;Frequently Asked Questions\u0026rdquo; layout = \u0026ldquo;faq\u0026rdquo; [menu.main] parent = \u0026ldquo;support\u0026rdquo; weight = 6 [menu.footer] parent = \u0026ldquo;support\u0026rdquo; weight = 6 pre = \u0026lsquo;\u0026rsquo; +++\n","date":"01-01-0001","img":"","permalink":"/en/faq/","series":null,"tags":null,"title":""},{"categories":null,"content":"","date":"01-01-0001","img":"","permalink":"/en/offline/","series":null,"tags":null,"title":"Offline"}]